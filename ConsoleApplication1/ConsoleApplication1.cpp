
//!!!!!!!!!!!Данный код требует разбиения на компоненты и рефакторинга(для себя)!!!!!!!!!!!

#include <iostream>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
using namespace std;
//Структура реализующая предложения
struct Sentence
{
	// поле, содержащее указатель на массив
	char* word;
	// поле, содержащее указатель на следующий элемент списка
	Sentence* next;
	// поле, содержащее указатель на следующий предыдущий элемент списка
	Sentence* prev;
};
//Структура реализующая последовательность
struct Sequence
{
	// поле, содержащее указатель на внутреннюю структуру
	Sentence* Root;
	//  поле, содержащее указатель на следующий элемент списка
	Sequence* next;
	// поле, содержащее указатель на текущее положение рабочего указателя внутренней структуры
	Sentence* job;
};
//Структура реализующая очередь
struct List
{
	// поле, содержащее указатель на внутреннюю структуру
	Sequence* Root;
	// поле, содержащее указатель на следующий элемент списка
	List* next;
	// поле, содержащее указатель на следующий предыдущий элемент списка
	List* prev;
	// поле, содержащее указатель на текущее положение рабочего указателя внутренней структуры
	Sequence* job;
};

//Прототипы некоторых функций.
void showElementInPtr(Sequence*);
Sentence* ReadElementPosledovateln(Sequence* j);
void IsJonStartSequance(Sequence*, Sequence*);
Sentence* DeleteWordBeforeJ(Sentence* j, Sentence* root);

Sentence* JtoEnd(Sentence* j) {
	// Если предложение пусто – выводит сообщение
	if (!j) {
		printf("\nПредложение пусто\n\n");
	}
	//Иначе – меняет значение рабочего указателя на «корень»
	else
	{
		while (j->next != NULL) {
			j = j->next;
		}
	}
	return j;
}

Sentence* TakeWordBeforeJ(Sentence* j, Sentence* root) {
	char* temp = NULL;
	// Если предложение пусто, выводит сообщение
	if (!j) {
		printf("\nПредложение пусто\n\n");
	}
	// Если значение указателя отлично от NULL
	else
	{
		//Считает колличество букв в слове
		if (j->prev != NULL) {
			int i = 0;
			// Увеличивает счётчик количества букв пока не дойдёт до символа \0
			while (j->prev->word[i] != '\0') {
				i++;
			}
			//Выделяет память в буфере под подсчитанное количество
			temp = (char*)malloc((i + 1) * sizeof(char));
			i = 0;
			//Заполняет буфер взятым словом посимвольно
			while (j->prev->word[i] != '\0') {
				temp[i] = j->prev->word[i];
				i++;
			}
			temp[i] = '\0';
			i = 0;
			// Печатает взятое слово посимвольно
			while (temp[i] != '\0') {
				printf("%c", temp[i]);
				i++;
			}
			printf("\n");
		}
		// Если указатель в конце предложения, печатает сообщение
		else
		{
			printf("\nУказатель в начале предложения, взять нельзя\n\n");
		}
		//Удаляет взятое слово из предложения
		root = DeleteWordBeforeJ(j, root);
	}
	return root;
}

Sentence* AddWordBeforeJ(Sentence* j, Sentence* root) {
	Sentence* temp = NULL; // Создаём буферы.
	Sentence* temp2 = NULL;
	int i = 0;
	char* c = (char*)malloc(sizeof(char));
	printf("\nВведите слово\n\n");
	scanf_s("%c", &c[i]);
	//Проверяет, верный ли формат у введённого слова, если неверный - сообщает об этом
	if (c[i] == '\n' || c[i] == '	' || c[i] == ' ') {
		printf("\nНеверный формат\n\n");
		int u = 0;
		u = getchar();
		//Очищает поток ввода
		while (u != '\n')
		{
			u = getchar();
		}
		free(c);
	}
	//Если верный - выделяет память и заполняет массив введённым словом
	else
	{
		//Посимвольно заполняет массив, введённым пользователем словом
		while (c[i] != '\n' && c[i] != '	' && c[i] != ' ') {
			i++;
			c = (char*)realloc(c, (i + 1) * sizeof(char));
			scanf_s("%c", &c[i]);
		}
		int y = c[i];
		c[i] = '\0';
		// Если сохранённый в переменной символ не является концов строки
		if (y != '\n') {
			int u = 0;
			u = getchar();
			//Очищает поток ввода
			while (u != '\n')
			{
				u = getchar();
			}
		}
		temp = (Sentence*)malloc(sizeof(Sentence));
		temp->word = (char*)malloc(i * sizeof(char));
		//Заполняет поле структурной переменной введённым словом посимвольно
		for (int k = 0; k < i + 1; k++) {
			temp->word[k] = c[k];
		}
		//Заполняет поле элемента, на который указывает рабочий указатель адресом этого элемента
		//Если начало 
		if (j->prev == NULL) {
			temp->next = j;
			temp->prev = NULL;
			j->prev = temp;
			root = temp;
		}
		else { //Если предыдущий элемент не начало списка.
			j = j->prev;
			Sentence* afterDel = j->next;
			if (j->prev != NULL) {
				j->next->prev = temp;
				j->next = temp;
				temp->next = afterDel;
				temp->prev = j;
			}
			else {
				j->next->prev = temp;
				j->next = temp;
				temp->next = afterDel;
				temp->prev = j;
				root = j;
			}
			j = afterDel;
		}
	}
	return root;
}

void ChangeWordBeforeJ(Sentence* j) {
	int i = 0;
	// Если предложение пусто, выводит сообщение
	if (!j) {
		printf("\nПредложение пусто\n\n");
	}
	// Если рабочий указатель отличен от NULL
	else
	{
		//Проверяет, есть ли слово после указателя, если нет - выводит сообщение
		if (!j->prev) {
			printf("\nУказатель на первом элементе, изменить нельзя\n\n");
		}
		// Если за элементом есть ещё один
		else
		{
			//Позвозяет пользователю ввести новое слово и, если формат допустим, заменяет им предыдущее
			char* c = (char*)malloc(sizeof(char));
			printf("\nВведите изменённое слово\n\n");
			scanf_s("%c", &c[i]);
			// Проверяет, верный ли формат введённого пользователем слова
			if (c[i] == '\n' || c[i] == '	' || c[i] == ' ') {
				printf("\nНеверный формат\n\n");
			}
			// Если формат верен
			else
			{
				// Выделяет память под новое слово
				while (c[i] != '\n' && c[i] != '	' && c[i] != ' ') {
					i++;
					c = (char*)realloc(c, (i + 1) * sizeof(char));
					scanf_s("%c", &c[i]);
				}
				c[i] = '\0';
			}
			//Заново выделяет память под изменённое слово
			j->prev->word = (char*)realloc(j->prev->word, i * sizeof(char));
			// Посимвольно заполняет поле элемента введённым словом
			for (int k = 0; k < i + 1; k++) {
				j->prev->word[k] = c[k];
			}
			printf("\n");
		}
	}
}

//Перегруженная функция для удаления слова после рабочего указателя
Sentence* DeleteWordAfterJ(Sentence* j, Sentence* root) {
	//Проверяет, не пусто ли предложение, а затем, есть ли слово после указателя, если нет - выводит сообщение
	if (j != NULL) {
		//Проверяет, есть ли слово после указателя, если нет - выводит сообщение
		if (j->next != NULL) {
			//Если да – переставляет поля связей других элементов, а память освобождает
			j = j->next;
			if (j->next != NULL) {
				Sentence* PredDel = j->prev;
				Sentence* afterDel = j->next;
				PredDel->next = afterDel;
				afterDel->prev = PredDel;
				free(j);
				j = afterDel;
			}
			else { // Если последний элемент.
				Sentence* j_help = j;
				j = j->prev;
				j->next->prev = NULL;

				j->next = NULL;
				free(j_help);
			}
		}
		// Если элемент – последний в списке, выводит соответствующее сообщение
		else
		{
			printf("\nУказатель находится в конце списка, удалить нельзя\n\n");
		}
	}
	// Если значение указателя равно NULL
	else
	{
		printf("\nПредложение пусто\n\n");
	}
	return root;
}

// Функция удаления слова до указателя
Sentence* DeleteWordBeforeJ(Sentence* j, Sentence* root) {
	//Проверяет, не пусто ли предложение, а затем, есть ли слово после указателя, если нет - выводит сообщение
	if (j != NULL) {
		//Проверяет, есть ли слово после указателя, если нет - выводит сообщение
		if (j->prev != NULL) {
			//Если да – переставляет поля связей других элементов, а память освобождает
			j = j->prev;
			if (j->prev != NULL) {
				Sentence* PredDel = j->prev;
				Sentence* afterDel = j->next;
				PredDel->next = afterDel;
				afterDel->prev = PredDel;
				free(j);
				j = afterDel;
			}
			else {
				Sentence* j_help = j;
				root = j->next;
				j->next->prev = NULL;
				j->prev = NULL;
				j = j->next;
				free(j_help);
			}
		}
		// Если элемент – последний в списке, выводит соответствующее сообщение
		else
		{
			printf("\nУказатель находится в начале списка, удалить нельзя\n\n");
		}
	}
	// Если значение указателя равно NULL
	else
	{
		printf("\nПредложение пусто\n\n");
	}
	return root;
}

void ShowWordBeforeJ(Sentence* j) {
	// Если предложение пусто, выводит сообщение
	if (!j) {
		printf("\nПредложение пусто\n\n");
	}
	else
	{
		//Проверяет, есть ли слово после указателя, если нет - выводит сообщение
		if (j->prev != NULL) {
			int i = 0;
			// Печатает слово после указателя посимвольно
			while (j->prev->word[i] != '\0') {
				printf("%c", j->prev->word[i]);
				i++;
			}
			printf("\n");
		}
		// Если указатель находится в конце предложения, выводит сообщение
		else
		{
			printf("\nУказатель находится в начале предложения, распечатать нельзя\n\n");
		}
	}
}

//Двигает рабочий указатель вперёд, если предложение не пусто
Sentence* MoveJBack(Sentence* j) {
	// Если значение указателя равно NULL
	if (!j) {
		printf("\nПредложение пусто\n\n");
	}
	// Иначе, запускает следующую проверку
	else
	{
		//Проверяет, можно ли подвинуть указатель, или он находится на последнем слове
		if (j->prev != NULL) {
			j = j->prev;
		}
		// Если нельзя, выводит соответствующее сообщение
		else
		{
			printf("\nУказатель находится в начале предложения, нельзя передвинуть\n\n");
		}
	}
	return j;
}

//Добавляет первое слово в предложение
Sentence* FirstWord() {
	Sentence* root = NULL;
	int i = 0;
	char* c = (char*)malloc(sizeof(char));
	printf("\nВведите первое слово\n\n");
	scanf_s("%c", &c[i]);
	//Проверяет, верный ли формат у введённого слова, если неверный - сообщает об этом
	if (c[i] == '\n' || c[i] == '	' || c[i] == ' ') {
		printf("\nНеверный формат\n\n");
		int u = 0;
		u = getchar();
		//Очищает поток ввода
		while (u != '\n')
		{
			u = getchar();
		}
		free(c);
	}
	//Если верный - выделяет память и заполняет массив введённым словом
	else
	{

		//Посимвольно заполняет массив, введённым пользователем словом
		while (c[i] != '\n' && c[i] != '	' && c[i] != ' ') {
			i++;
			c = (char*)realloc(c, (i + 1) * sizeof(char));
			scanf_s("%c", &c[i]);
		}
		int y = c[i];
		c[i] = '\0';
		// Если сохранённый в переменной символ не является концов строки
		if (y != '\n') {
			int u = 0;
			u = getchar();
			//Очищает поток ввода
			while (u != '\n')
			{
				u = getchar();
			}
		}
		root = (Sentence*)malloc(sizeof(Sentence));
		root->word = (char*)malloc(i * sizeof(char));
		//Заполняет поле структурной переменной введённым словом посимвольно
		for (int j = 0; j < i + 1; j++) {
			root->word[j] = c[j];
		}
		root->next = NULL;
		root->prev = NULL;
	}
	return root;
}
//Добавляет каждое последующее слово в предложение после указателя
void AddWord(Sentence* j) {
	Sentence* temp = NULL;
	Sentence* temp2 = NULL;
	int i = 0;
	char* c = (char*)malloc(sizeof(char));
	printf("\nВведите слово\n\n");
	scanf_s("%c", &c[i]);
	//Проверяет, верный ли формат у введённого слова, если неверный - сообщает об этом
	if (c[i] == '\n' || c[i] == '	' || c[i] == ' ') {
		printf("\nНеверный формат\n\n");
		int u = 0;
		u = getchar();
		//Очищает поток ввода
		while (u != '\n')
		{
			u = getchar();
		}
		free(c);
	}
	//Если верный - выделяет память и заполняет массив введённым словом
	else
	{
		//Посимвольно заполняет массив, введённым пользователем словом
		while (c[i] != '\n' && c[i] != '	' && c[i] != ' ') {
			i++;
			c = (char*)realloc(c, (i + 1) * sizeof(char));
			scanf_s("%c", &c[i]);
		}
		int y = c[i];
		c[i] = '\0';
		// Если сохранённый в переменной символ не является концов строки
		if (y != '\n') {
			int u = 0;
			u = getchar();
			//Очищает поток ввода
			while (u != '\n')
			{
				u = getchar();
			}
		}
		temp = (Sentence*)malloc(sizeof(Sentence));
		temp->word = (char*)malloc(i * sizeof(char));
		//Заполняет поле структурной переменной введённым словом посимвольно
		for (int k = 0; k < i + 1; k++) {
			temp->word[k] = c[k];
		}
		//Заполняет поле элемента, на который указывает рабочий указатель адресом этого элемента

		if (j->next == NULL) {
			j->next = temp;
			temp->prev = j;
			temp->next = NULL;
		}
		else {
			temp2 = j->next;
			j->next = temp;
			temp->next = temp2;
			temp->prev = j;
			temp2->prev = temp;
		}
	}
}
// Функция удаления слова после указателя
void DeleteWord(Sentence* j) {
	//Проверяет, не пусто ли предложение, а затем, есть ли слово после указателя, если нет - выводит сообщение
	if (j != NULL) {
		//Проверяет, есть ли слово после указателя, если нет - выводит сообщение
		if (j->next != NULL) {
			//Если да – переставляет поля связей других элементов, а память освобождает
			Sentence* temp1 = NULL;
			temp1 = j->next->next;
			free(j->next);
			j->next = temp1;
		}
		// Если элемент – последний в списке, выводит соответствующее сообщение
		else
		{
			printf("\nУказатель находится в конце списка, удалить нельзя\n\n");
		}
	}
	// Если значение указателя равно NULL
	else
	{
		printf("\nПредложение пусто\n\n");
	}
}
// Функция печатает всё предложение целиком
void PrintSentence(Sentence* root) {
	Sentence* temp;
	// Если предложение пусто, выводит сообщение
	if (!root) {
		printf("\nПредложение пусто\n\n");
	}
	// Иначе, печатает
	else
	{
		//Пока указатель не на последнем элементе, печатает каждый
		if (!root->next) {
			int i = 0;
			// Печатает поле каждого элемента посимвольно
			while (root->word[i] != '\0') {
				printf("%c", root->word[i]);
				i++;
			}
		}
		// Указатель стоит на последнем элементе
		else
		{
			int i = 0;
			// Печатает поле последнего элемента посимвольно
			while (root->word[i] != '\0') {
				printf("%c", root->word[i]);
				i++;
			}
			root = root->next;
			printf(" ");
			while (root->next != NULL)
			{
				i = 0;
				// Печатает слово посимвольно
				while (root->word[i] != '\0') {
					printf("%c", root->word[i]);
					i++;
				}
				root = root->next;
				printf(" ");
			}
			i = 0;
			// Печатает слово посимвольно
			while (root->word[i] != '\0') {
				printf("%c", root->word[i]);
				i++;
			}
		}
	}
}
//Удаляет всё предложение целиком
Sentence* DeleteAll(Sentence* root, Sentence** j) {
	// Если предложение пусто, выводит сообщение
	if (!root)
	{
		printf("\nПредложение и так пусто\n\n");
	}
	// Если значение указателя отлично от NULL
	else
	{
		//Последовательно вызывает функцию "удалить слово" для каждого слова в предложении кроме корня
		while (root->next != NULL)
		{
			DeleteWord(root);
		}
	}
	//Освобождает корень
	*j = NULL;
	free(root);
	return NULL;
}
//Проверяет пустоту предложения с помощью рабочего указателя
void IsEmpty(Sentence* j) {
	// Если предложение не пусто – выводит соответствующее сообщение
	if (j != NULL) {
		printf("\nПредложение HE пусто\n\n");
	}
	// Иначе – выводит сообщение о пустоте
	else
	{
		printf("\nПредложение пусто\n\n");
	}
}
//Начинает работу программы, выставляя нужное значение bool
bool StartWork(bool IsA) {
	IsA = true;
	printf("Вы успешно начали работу\n");
	return IsA;
}

//Если предложение не пусто, ставит рабочий указатель на его первый элемент
Sentence* JtoStart(Sentence* j, Sentence* root) {
	// Если предложение пусто – выводит сообщение
	if (!j) {
		printf("\nПредложение пусто\n\n");
	}
	//Иначе – меняет значение рабочего указателя на «корень»
	else
	{
		j = root;
	}
	return j;
}
//Проверяет, находится ли рабочий указатель в конце предложения, если оно не пусто
void IsJonEnd(Sentence* j) {
	//Если предложение пусто, выводит сообщение
	if (!j) {
		printf("\nПредложение пусто\n\n");
	}
	// Если значение указателя отлично от NULL
	else
	{
		// Иначе, проверяет, находится ли указатель в конце предложения или нет и выводит соответствующее сообщение
		if (j->next == NULL) {
			printf("\nУказатель находится в конце предложения\n\n");
		}
		// Если элемент находится в конце предложения
		else
		{
			printf("\nУказатель находится НЕ в конце предложения\n\n");
		}
	}
}
//Двигает рабочий указатель вперёд, если предложение не пусто
Sentence* MoveJForward(Sentence* j) {
	// Если значение указателя равно NULL
	if (!j) {
		printf("\nПредложение пусто\n\n");
	}
	// Иначе, запускает следующую проверку
	else
	{
		//Проверяет, можно ли подвинуть указатель, или он находится на последнем слове
		if (j->next != NULL) {
			j = j->next;
		}
		// Если нельзя, выводит соответствующее сообщение
		else
		{
			printf("\nУказатель находится в конце предложения, нельзя передвинуть\n\n");
		}
	}
	return j;
}
//Печатает слово после указателя, если предложение не пусто
void ShowWordAfterJ(Sentence* j) {
	// Если предложение пусто, выводит сообщение
	if (!j) {
		printf("\nПредложение пусто\n\n");
	}
	else
	{
		//Проверяет, есть ли слово после указателя, если нет - выводит сообщение
		if (j->next != NULL) {
			int i = 0;
			// Печатает слово после указателя посимвольно
			while (j->next->word[i] != '\0') {
				printf("%c", j->next->word[i]);
				i++;
			}
			printf("\n");
		}
		// Если указатель находится в конце предложения, выводит сообщение
		else
		{
			printf("\nУказатель находится в конце предложения, распечатать нельзя\n\n");
		}
	}
}
//Изменяет слово после указателя, если предложение не пусто
void ChangeWordAfterJ(Sentence* j) {
	int i = 0;
	// Если предложение пусто, выводит сообщение
	if (!j) {
		printf("\nПредложение пусто\n\n");
	}
	// Если рабочий указатель отличен от NULL
	else
	{
		//Проверяет, есть ли слово после указателя, если нет - выводит сообщение
		if (!j->next) {
			printf("\nУказатель на последнем элементе, изменить нельзя\n\n");
		}
		// Если за элементом есть ещё один
		else
		{
			//Позвозяет пользователю ввести новое слово и, если формат допустим, заменяет им предыдущее
			char* c = (char*)malloc(sizeof(char));
			printf("\nВведите изменённое слово\n\n");
			scanf_s("%c", &c[i]);
			// Проверяет, верный ли формат введённого пользователем слова
			if (c[i] == '\n' || c[i] == '	' || c[i] == ' ') {
				printf("\nНеверный формат\n\n");
			}
			// Если формат верен
			else
			{
				// Выделяет память под новое слово
				while (c[i] != '\n' && c[i] != '	' && c[i] != ' ') {
					i++;
					c = (char*)realloc(c, (i + 1) * sizeof(char));
					scanf_s("%c", &c[i]);
				}
				c[i] = '\0';
			}
			//Заново выделяет память под изменённое слово
			j->next->word = (char*)realloc(j->next->word, i * sizeof(char));
			// Посимвольно заполняет поле элемента введённым словом
			for (int k = 0; k < i + 1; k++) {
				j->next->word[k] = c[k];
			}
			printf("\n");
		}
	}
}
//Помещает слово после указателя в буфер обмена, если предложение не пусто
char* TakeWordAfterJ(Sentence* j) {
	char* temp = NULL;
	// Если предложение пусто, выводит сообщение
	if (!j) {
		printf("\nПредложение пусто\n\n");
	}
	// Если значение указателя отлично от NULL
	else
	{
		//Считает колличество букв в слове
		if (j->next != NULL) {
			int i = 0;
			// Увеличивает счётчик количества букв пока не дойдёт до символа \0
			while (j->next->word[i] != '\0') {
				i++;
			}
			//Выделяет память в буфере под подсчитанное количество
			temp = (char*)malloc((i + 1) * sizeof(char));
			i = 0;
			//Заполняет буфер взятым словом посимвольно
			while (j->next->word[i] != '\0') {
				temp[i] = j->next->word[i];
				i++;
			}
			temp[i] = '\0';
			i = 0;
			// Печатает взятое слово посимвольно
			while (temp[i] != '\0') {
				printf("%c", temp[i]);
				i++;
			}
			printf("\n");
		}
		// Если указатель в конце предложения, печатает сообщение
		else
		{
			printf("\nУказатель в конце предложения, взять нельзя\n\n");
		}
		//Удаляет взятое слово из предложения
		DeleteWord(j);
	}
	return temp;
}
//Заканчивает работу, выставляя нужное значение переменной int
int EndWorkSentence(int menu) {
	menu = 1;
	return menu;
}
//Печатает рабочий указатель в нужном положении
void PrintJWord(Sentence* root, Sentence* j) {

	// Если предложение пусто, выводит сообщение
	if (!root) {
		//В пустом предложении печатать указатель нельзя
	}
	// Если значение указателя отлично от NULL
	else
	{
		//Печатает пробел каждый раз пока не дойдёт до первого символа слова, на которое указывает рабочий указатель
		while (root != j) {
			int i = 0;
			// Печатает пробелы пока не дойдёт до символа \0
			while (root->word[i] != '\0') {
				printf(" ");
				i++;
			}
			root = root->next;
			printf(" ");
		}
		//Затем печатает специальный символ
		printf("^\n");
		//printf("|\n");
	}
}
//Общая функция, реализующая работу с предложением
Sentence* WorkWithSentence(Sentence* root, Sentence** job) {
	bool isActive = false; // флаг активации работы
	int menu = 0; // флаг работы с меню
	int temp = 0; // флаг работы с введённой командой
	Sentence* j = *job; // рабочему указателю присваивается значение, переданное в функцию извне
	//Цикл, реализующий меню диалогового режима
	while (!menu) {
		printf("1. Начать работу с предложением\n");
		printf("2. Сделать предложение пустым\n");
		printf("3. Пусто ли предложение?\n");
		printf("4. Установить рабочий указатель в начало предложения\n");
		printf("5. Установить указатель в конец предложения.\n");
		printf("6. Рабочий указатель в конце предложения?\n");
		printf("7. Передвинуть рабочий указатель вперёд\n");
		printf("8. Передвинуть рабочий указатель назад\n");
		printf("9. Показать слово за рабочим указателем\n");
		printf("10. Показать слово до рабочего указателя\n");
		printf("11. Удалить слово за указателем\n");
		printf("12. Удалить слово перед рабочим указателем\n");
		printf("13. Взять слово за указателем\n");
		printf("14. Взять слово до указателя\n");
		printf("15. Изменить слово за указателем\n");
		printf("16. Изменить слово до рабочего указателя\n");
		printf("17. Добавить слово за указателем\n");
		printf("18. Добавить слово перед указателем\n");
		printf("19. Распечатать предложение\n");
		printf("20. Закончить работу с предложением\n");
		//Запрос ввода команды от пользователя
		scanf_s("%d", &temp);
		system("cls"); // очищение экрана
		int y = 0;
		y = getchar();
		while (y != '\n') {
			y = getchar();
		}
		//Проверка на активность меню и допустимость действий
		if (!isActive && (temp != 13) && (temp != 1)) {
			printf("\nДля доступа к этой функции необходимо начать работу\n\n");
			temp = 0;
		}
		// Если меню активировано и введённая команда допустима
		else
		{

			//Проверка на верность формата
			if (temp == 0) {
				printf("\nНеверный формат команды\n\n");
			}
		}
		//Ветвление, реализующее выполнение команды, введённой пользователем
		switch (temp)
		{
		case 1:
			// Активация меню 
			isActive = StartWork(isActive);
			break;
		case 2:
			// Полное удаление списка
			root = DeleteAll(root, &j);
			break;
		case 3:
			// Проверка на пустоту
			IsEmpty(j);
			break;
		case 4:
			// Ставит рабочий указатель в начало списка
			j = JtoStart(j, root);
			break;
		case 6:
			// Проверка, в конце ли списка рабочий указатель
			IsJonEnd(j);
			break;
		case 7:
			// Двигает рабочий указатель вперёд
			j = MoveJForward(j);
			break;
		case 9:
			// Печатает слово после рабочего указателя
			ShowWordAfterJ(j);
			break;
		case 11:
			// Удаляет слово после рабочего указателя
			root = DeleteWordAfterJ(j, root);
			break;
		case 13:
			// Помещает слово после рабочего указателя в буфер
			TakeWordAfterJ(j);
			break;
		case 15:
			// Изменяет слово после рабочего указателя
			ChangeWordAfterJ(j);
			break;
		case 17:
			//Проверка, какое слово по счёту вводит пользователь, в зависимости от которой вызывается функция
			if (j == NULL) {
				// Добавление первого слова
				root = FirstWord();
				j = root;
			}
			// Если указатель не равен нулю, вызывает функцию добавления слова
			else
			{
				AddWord(j);
			}
			break;
		case 19:
			printf("\n");
			// Печатает предложение полностью
			PrintSentence(root);
			printf("\n");
			break;
		case 20:
			// Выходит из меню
			menu = EndWorkSentence(menu);
			break;

		case 8:
			// Передвинуть рабочий указатель назад
			j = MoveJBack(j);
			break;
		case 10:
			// Показать слово до рабочего указателя
			ShowWordBeforeJ(j);
			break;
		case 12:
			// Удалить слово перед рабочим указателем
			root = DeleteWordBeforeJ(j, root);
			break;
		case 16:
			// Изменяет до после рабочего указателя
			ChangeWordBeforeJ(j);
			break;
		case 18:
			// Добавить после указателя.
			//root = AddWordBeforeJ(j, root);
			//Проверка, какое слово по счёту вводит пользователь, в зависимости от которой вызывается функция
			if (j == NULL) {
				// Добавление первого слова
				root = FirstWord();
				j = root;
			}
			// Если указатель не равен нулю, вызывает функцию добавления слова
			else
			{
				root = AddWordBeforeJ(j, root);
			}
			break;
		case 14:
			// Помещает слово до рабочего указателя в буфер
			root = TakeWordBeforeJ(j, root);
			break;
		case 5:
			//Установить указатель в конец предложения.
			j = JtoEnd(j);
			break;
		}
		//Печать предложения и рабочего указателя
		if (isActive)
		{
			printf("\n");
			PrintSentence(root);
			printf("\n");
			PrintJWord(root, j);
			printf("\n");
		}
		temp = 0;
	}
	//Положение рабочего указателя сохраняется по адресу, корень списка возвращается функцией
	*job = j;
	j = NULL;
	return root;
}
//Добавляет первое предложение последовательности
Sequence* AddFirstSentence() {
	//Выделяет память и заполняет поля первой структурной переменной значениями NULL
	Sequence* temp = (Sequence*)malloc(sizeof(Sequence));
	temp->next = NULL;
	//temp->prev = NULL;
	temp->job = NULL;
	//Вызывает функцию работы с предложением
	temp->Root = WorkWithSentence(NULL, &(temp->job));
	//Проверяет, создал ли пользователь предложение, если нет - освобождает память
	if (temp->Root == NULL) {
		free(temp);
		temp = NULL;
	}
	return temp;
}

//Добавляет каждое последующее предложение последовательности
Sequence* AddSentence(Sequence* j, int ab, Sequence* root) {
	//Выделяет память
	Sequence* temp = (Sequence*)malloc(sizeof(Sequence));
	//Создаёт и инициализирует временные переменные
	Sequence* temp2 = NULL;
	Sentence* tq = NULL;
	// Если значение указателя равно NULL
	if (!j) {
		//Если Отсутствуют какие-либо записи, эта функция не вызовется
	}
	// Если значение указателя отлично от NULL
	else
	{
		//Запускает функцию работы с предложением, позволяя пользователю ввести его, но сохраняет в буфер
		temp->job = NULL;
		tq = WorkWithSentence(NULL, &(temp->job));
		// Если значение указателя равно NULL
		if (!tq) {
			//Если пользователь не ввёл ничего, просто не присваивает адрес, сохранённый в буфере, переменной
		}
		// Если значение указателя отлично от NULL
		else
		{
			//Если пользователь ввёл предложение, в зависимости от того, как вызвана функция, добавляет если либо до либо после указателя
			if (ab == 0) {
				//После
				//Если предложение будет не последним в последовательностье
				if (j->next != NULL) {
					//j->next->prev = temp;
					temp2 = j->next;
					j->next = temp;
					temp->next = temp2;
					temp->Root = tq;
				}
				//Если будет последним
				else
				{
					j->next = temp;
					temp->next = NULL;
					temp->Root = tq;
				}
			}
		}
	}
	return root;
}
//Печатает весь последовательность
void PrintSequence(Sequence* root) {
	// Если Отсутствуют какие-либо записи, выводит сообщение
	if (!root) {
		//Пустой последовательность нельзя напечатать
	}
	// Если последовательность не пуст
	else
	{
		printf("\n");
		//Последовательно для каждого предложения вызывает функцию печати, затем переходит к следующему через указатель
		while (root->next != NULL)
		{
			PrintSentence(root->Root);
			printf("\n");
			root = root->next;
		}
		//Печатает последнее предложение
		PrintSentence(root->Root);
		printf("\n");
	}
}
//Печатает последовательность в обратном порядке
//void PrintSequenceAround(Sequence* root) {
//	// Если Отсутствуют какие-либо записи, выводит сообщение
//	if (!root) {
//		//Пустой последовательность нельзя напечатать
//	}
//	// Если последовательность не пуст
//	else
//	{
//		printf("\n");
//		//Перемещает указатель на последний элемент последовательности
//		while (root->next != NULL) {
//			root = root->next;
//		}
//		//Последовательно вызывает функцию печати для каждого предложения пока не дойдёт до первого
//		while (root->prev != NULL)
//		{
//			PrintSentence(root->Root);
//			printf("\n");
//			root = root->prev;
//		}
//		//Печатает первое предложение
//		PrintSentence(root->Root);
//		printf("\n");
//	}
//}

//Проверяет, пуст ли последовательность
void IsSequenceEmpty(Sequence* root) {

	// Если Отсутствуют какие-либо записи, выводит сообщение
	if (!root)
	{
		printf("\nПоследовательност пуста\n\n");
	}
	// Иначе, выводит сообщение о том, что он не пуст
	else
	{
		printf("\nПоследовательность НE пуста\n\n");
	}
}
// Ставит рабочий указатель на первый элемент последовательности
Sequence* JtoStartSequence(Sequence* root, Sequence* j) {
	//Если Отсутствуют какие-либо записи или указатель уже на первом элементе - выводит соответствующее сообщение
	if (!j) {
		printf("\nОтсутствуют какие-либо записи\n\n");
	}
	//Иначе, выводит сообщение о положении указателя
	else
	{
		if (j == root) {
			printf("\nУказатель уже находится в начале\n\n");
		}
		//Иначе, ставит указатель на "корень" последовательности
		else
		{
			j = root;
		}
	}
	return j;
}


//Перемещает указатель вперёд
Sequence* MoveJForwardSequence(Sequence* j) {
	//Если Отсутствуют какие-либо записи, выводит сообщение
	if (!j) {
		printf("\nОтсутствуют какие либо записи\n\n");
	}
	else
	{
		//Если за указателем есть элемент - перемещает его вперёд
		if (j->next != NULL) {
			j = j->next;
		}
		//Иначе, выводит сообщение
		else
		{
			printf("\nУказатель уже находится на последнем элементе, нельзя двигать\n\n");
		}
	}
	return j;
}


//Удялет элемент после указателя
void DeleteElementAfterJSequence(Sequence* j) {
	//Создаёт буферы
	Sequence* temp = NULL;
	Sequence* temp2 = NULL;
	Sentence* n = NULL;
	//Если Отсутствуют какие-либо записи, выводит сообщение
	if (!j) {
		printf("\nОтсутствуют какие-либо записи\n\n");
	}
	// Если последовательность не пуст
	else
	{
		//Если после указателя есть элемент, вызывает функцию удаления предложения, а поля связей переставляет
		if (j->next != NULL) {
			//Если удаляемый элемент - не последний в последовательностье, меняет поля связей в последовательностье
			if (j->next->next != NULL) {
				temp2 = j->next;
				temp = j->next->next;
				//j->next->next->prev = j;
				j->next = temp;
				//Вызывает функцию удаления предложения
				DeleteAll(temp2->Root, &n);
				free(temp2);
			}
			//Иначе, если после нет других элементов
			else
			{
				temp = j->next;
				j->next = NULL;
				DeleteAll(temp->Root, &n);
				free(temp);
			}
		}
		// Если за указателем нет элементов, выводит сообщение
		else
		{
			printf("\nУказатель находится на последнем элементе, удалить нельзя\n\n");
		}
	}
}


//Берёт элемент после указателя и помещает в буфер
void TakeElementAfterJSequence(Sequence* j, Sentence** t) {
	// Если Отсутствуют какие-либо записи, выводит сообщение
	if (!j) {
		printf("\nОтсутствуют какие-либо записи\n\n");
	}
	// Если последовательность не пуст
	else
	{
		//Если указатель на последнем предложении, выводит сообщение
		if (!j->next) {
			printf("\nУказатель находится на последнем предложении, взять нельзя\n\n");
		}
		// Если за указателем есть другие элементы
		else
		{
			//Создаёт буферы
			*t = (Sentence*)malloc(sizeof(Sentence));
			*t = j->next->Root;
			Sequence* temp = NULL;
			Sequence* temp2 = NULL;
			Sentence* n = NULL;

			// Если Отсутствуют какие-либо записи, выводит сообщение
			if (!j) {
				printf("\nОтсутствуют какие-либо записи\n\n");
			}
			// Если последовательность не пуст
			else
			{
				//Если после указателя есть элемент, вызывает функцию удаления предложения, а поля связей переставляет
				if (j->next != NULL) {
					//Если элемент - не последний в последовательностье, меняет поля связей в последовательностье
					if (j->next->next != NULL) {
						//Предложение помещается в буфер
						temp2 = j->next;
						temp = j->next->next;
						//j->next->next->prev = j;
						j->next = temp;
					}
					//Если элемент - последний, меняет поля связей
					else
					{
						//Предложение помещается в буфер
						temp = j->next;
						j->next = NULL;
					}
				}
				// Иначе выводит сообщение о невозможности удаления элемента
				else
				{
					printf("\nУказатель находится на последнем элементе, удалить нельзя\n\n");
				}

				//Печатает взятое предложение
				PrintSentence(*t);
			}
		}
	}
}

//Изменяет предложение после указателя
Sentence* ChangeElementAfterJSequence(Sequence* j) {
	Sentence* r = NULL;

	//Если Отсутствуют какие-либо записи - выводит сообщение
	if (!j) {
		printf("\nОтсутствуют какие-либо записи\n\n");
	}
	// Если последовательность не пуст
	else
	{
		// Если указатель на последнем предложении - выводит сообщение
		if (j->Root == NULL) {
			printf("\nУказатель находится на последнем предложении, изменить нельзя\n\n");
		}
		// Если за указателем есть ещё элементы
		else
		{
			//Иначе, запускает функцию работы с предложением
			r = WorkWithSentence(j->Root, &(j->job));
		}
	}
	return r;
}
//Удаляет весь последовательность
Sequence* DeleteAllSequence(Sequence* root, Sequence** j) {
	//Если Отсутствуют какие-либо записи - выводит сообщение
	if (!root) {
		printf("\nОтсутствуют какие-либо записи\n\n");
	}
	// Если последовательность не пуст
	else
	{
		//Для каждого предложения начиная с первого вызывает функцию удаления
		while (root->next != NULL)
		{
			DeleteElementAfterJSequence(root);
		}
		//Освобождает память под последним предложеним
		free(root);
	}
	//Обнуляет рабочий указатель
	*j = NULL;
	return NULL;
}
//Печатает последовательность и рабочий указатель
void PrintJSequence(Sequence* root, Sequence* j) {
	//Если Отсутствуют какие-либо записи - выводит сообщение
	if (!root) {
		printf("\nОтсутствуют какие-либо записи\n\n");
	}
	// Если последовательность не пуст
	else
	{
		printf("\n");
		//Вызывает функцию печати предложения и его рабочего указателя и меняет указатель на следующий
		while (root->next != NULL)
		{
			//Проверяет, совпадает ли предложение с текущим значением рабочего указателя последовательности
			if (root != j) {
				//Если нет - печатает предложение
				PrintSentence(root->Root);
				printf("\n");
				PrintJWord(root->Root, root->job);
				root = root->next;
			}
			//Если да - печатает предложение и специальный символ
			else
			{
				PrintSentence(root->Root);
				printf("  <--");
				printf("\n");
				PrintJWord(root->Root, root->job);
				root = root->next;
			}
		}
		//Печатает последнее предложение с/без символом рабочего указателя в зависимости от его значения
		if (root != j) {
			PrintSentence(root->Root);
			printf("\n");//
			PrintJWord(root->Root, root->job);
		}
		// Если значение указателя совпадает со значением рабочего
		else
		{
			// Печатает предложение
			PrintSentence(root->Root);
			// Печатает специальный символ
			printf("  <--");
			printf("\n");
			// Печатает рабочий указатель внутренней структуры
			PrintJWord(root->Root, root->job);
		}
	}
}
//Общая функция работы с последовательностьом
Sequence* WorkWithSequence(Sequence* root, Sequence** job) {

	bool isActive = false; //Флаг активации
	int menu = 0; //Флаг работы с меню
	int temp = 0; //Флаг работы с вводом
	Sequence* j = *job; //Рабочий указатель получает значение, переданное в функцию
	Sentence* RememberItem = NULL; //Для 6 пункта
	Sentence* taken = NULL; //буфер
	Sequence* head = NULL;
	//Цикл реализует меню в диалоговом режиме
	while (!menu) {
		printf("1.Начать работу с последовательностью\n");
		printf("2.Сделать последовательность пустой.\n");
		printf("3.Проверека, является ли последовательность пустой.\n");
		printf("4.Показать значение очередного элемента.\n");
		printf("5.Пропустить очередной элемент последовательности.\n");
		printf("6.Прочесть очередной элемент элемент последовательности.\n");
		printf("7.Изменить значение очередного элемента.\n");
		printf("8.Добавить элемент, в конец последовательности.\n");
		printf("9.Установить указатель очередного элемента в начало последовательности.\n");
		printf("10.Проверка есть или нет непрочитанных элементов\n");
		printf("11.Распечатать саму последовательность.\n");
		printf("12.Закончить работу с последовательностью.\n");
		//Ввод команды пользователем
		scanf_s("%d", &temp);
		system("cls"); // очищение экрана
		int y = 0;
		y = getchar();
		while (y != '\n') {
			y = getchar();
		}
		//Проверка на активацию меню 
		if (!isActive && (temp != 21) && (temp != 1)) {
			printf("\nДля доступа к этой функции необходимо начать работу\n\n");
			temp = 0;
		}
		// Если меню активировано 
		else
		{
			//Проверка на верность формата введённой команды
			if (temp == 0) {
				printf("\nНеверный формат команды\n\n");
			}
		}
		//Ветвление, реализующее вызов запрошенной пользователем функции
		switch (temp)
		{
		case 1:
			// Активация меню
			isActive = StartWork(isActive);
			break;
		case 2:
			// Удаление последовательности полностью
			root = DeleteAllSequence(root, &j);
			break;
		case 3:
			// Проверка, пуст ли последовательность
			IsSequenceEmpty(root);
			break;
		case 4:
			//Показывает элемент последовательности
			showElementInPtr(root);
			break;
		case 5:
			//Пропускаем очередной элемент последовательности
			j = MoveJForwardSequence(j);
			break;
		case 6:
			//читаем очередной элемент последовательности и помещаем его в прочитанную часть.
			RememberItem = ReadElementPosledovateln(j);
			j = MoveJForwardSequence(j);
			break;
		case 7:
			if (j) {
				//Проверка на наличие элемента после указателя
				if (j->Root) {
					// Изменяет элемент после рабочего указателя
					j->Root = ChangeElementAfterJSequence(j);
					//Если пользователь в результате "изменения" - удалил предложение, запускает соответствующую функцию
					if (!(j->job)) {
						// Удаляет элемент после рабочего указателя
						DeleteElementAfterJSequence(j);
					}
				}
			}
			break;
		case 8:
			if (!root) {
				//Если первое - запускает соответствующую функцию
				root = AddFirstSentence();
				j = root;
				head = j;
			}
			// Если второе – запускает соответствующую функцию
			else
			{
				// Добавляет элемент после указателя
				root = AddSentence(j, 0, root);
			}
			break;
		case 9:
			// Ставит рабочий указатель в начало последовательности
			j = JtoStartSequence(root, j);
			break;
		case 10:
			IsJonStartSequance(j, head);
			break;
		case 11:
			//Печатает последовательность в прямом и обратном порядках
			PrintSequence(root);
			printf("\n");
			//PrintSequenceAround(root);
			break;
		case 12:
			menu = EndWorkSentence(menu);
			break;
		}
		//Печатает последовательность
		// Если работа с функцией начата пользователем, печатает последовательность и рабочий указатель
		if (isActive) {
			printf("\n");
			PrintJSequence(root, j);
			printf("\n");
		}
		temp = 0;
	}
	//Сохраняет значение рабочего указателя по адресу
	*job = j;
	j = NULL;
	return root;
}
//Добавляет первый последовательность в очередь
List* AddFirstList() {
	//Выделяет память
	List* root = (List*)malloc(sizeof(List));
	//Создаёт буферы
	root->next = NULL;
	root->job = NULL;
	//Вызывает функцию работы с последовательностьом
	root->Root = WorkWithSequence(NULL, &(root->job));

	//Если пользователь ничего не создал - освобождает память
	if (!root->Root) {
		free(root);
		root = NULL;
	}
	return root;
}
//Добавляет каждый последующий последовательность
void AddList(List* root) {
	// Если очередь пуста, выводит сообщение
	if (!root) {
		printf("\nОчередь пуста\n\n");
	}
	//Иначе, продолжает добавление элемента очереди
	else
	{
		//Выделяет память
		List* l = (List*)malloc(sizeof(List));
		//Создаёт буфер
		Sequence* tq = NULL;
		//Находит последний элемент очереди
		while (root->next != NULL) {
			root = root->next;
		}
		//Запускает функцию работы с последовательностьом
		tq = WorkWithSequence(NULL, &(l->job));
		//Если ничего не создано - память освобождается
		if (!tq) {
			free(l);
		}
		//Иначе, создаёт новый последний элемент очереди
		else
		{
			root->next = l;
			l->next = NULL;
			l->Root = tq;
		}
	}
}
//Печатает очередь целиком
void PrintList(List* root) {
	//Если очередь пуста, выводит сообщение
	if (!root) {
		printf("\nОчередь пуста\n\n");
	}
	else
	{
		//Иначе, печатает все элементы очереди, начиная с первого
		//вызывая соответствующую функцию
		printf("\n");
		while (root->next != NULL)
		{
			PrintSequence(root->Root);
			printf("\n");
			root = root->next;
		}
		PrintSequence(root->Root);
		printf("\n");
	}
}
//Печатает рабочие указатели всех элементов очереди
void PrintJList(List* root) {
	//Если очередь пуста, выводит сообщение
	if (!root) {
		printf("\nОчередь пуста\n\n");
	}
	// Если очередь не пуста
	else
	{
		printf("\n");
		//Иначе, печатает все рабочие указатели очереди, начиная с первого
		//вызывая соответствующую функцию
		while (root->next != NULL)
		{
			//Вызов функции для печати внутреннего указателя
			PrintJSequence(root->Root, root->job);
			printf("\n");
			root = root->next;
		}
		//Печатает элементы последовательности
		PrintJSequence(root->Root, root->job);
		printf("\n");
	}
}
//Проверяет, пуста ли очередь
void IsListEmpty(List* root) {
	if (!root) {
		printf("\nОчередь пуста\n\n");
	}
	else
	{
		printf("\nОчередь НЕ пуста\n\n");
	}
}
//Печатает последовательность в начале очереди, если она не пуста
void ShowListonStart(List* root) {
	if (!root) {
		printf("\nОчередь пуста\n\n");
	}
	else
	{
		PrintSequence(root->Root);
	}
}
//Изменяет значение последовательности в начале очереди, если она не пуста
List* ChangeSequenceonList(List* root) {
	if (!root) {
		printf("\nОчередь пуста\n\n");
	}
	else
	{
		//Вызывает соответствующую функцию работы с последовательностьом
		root->Root = WorkWithSequence(root->Root, &(root->job));
	}

	return root;
}
//Удаляет элемент в начале очереди
List* DeleteStartList(List* root) {
	//Создаёт буферы
	List* temp = NULL;
	Sequence* n = NULL;
	//Если очередь пуста - выводит сообщение
	if (!root) {
		printf("\nОчередь пуста\n\n");
	}
	//Иначе, вызывает соответствующую функцию удаления последовательности
	else
	{
		//Если в очереди не один элемент
		if (!root->next) {
			DeleteAllSequence(root->Root, &n);
			//Освобождает память
			free(root);
			//Зануляет "корень" очереди
			root = NULL;
		}
		//Если один
		else
		{
			temp = root;
			root = root->next;
			DeleteAllSequence(temp->Root, &n);
			free(temp);
		}
	}

	return root;
}
//Делает очередь пустой
List* MakeListEmpty(List* root) {
	//Если очередь пуста - выводит сообщение
	if (!root) {
		printf("\nОчередь пуста\n\n");
	}
	else
	{
		//Для каждого элемента очереди вызывает соответствующую функцию
		while (root != NULL)
		{
			root = DeleteStartList(root);
		}

	}
	return NULL;
}
//Помещает элемент в начале очереди в буфер обмена и удаляет
List* TakeElementList(List* root, Sequence** t) {
	//Если очередь пуста - выводит сообщение
	if (!root) {
		printf("\nОчередь пуста\n\n");
	}
	else
	{
		//Создаёт буферы
		*t = root->Root;
		List* temp = NULL;
		Sequence* n = NULL;
		//Если очередь пуста - выводит сообщение
		if (!root) {
			printf("\nОчередь пуста\n\n");
		}
		else
		{
			//Иначе, меняет поля связей
			if (!root->next) {
				root = NULL;
			}
			else
			{
				//Адрес элемента сохраняет в буфер
				temp = root;
				root = root->next;
			}
			//Печатает взятый элемент
			PrintSequence(*t);
		}
	}
	return root;
}

//Общая функция работы с очердью
void WorkWithList() {
	bool isActive = false; //флаг активации
	int menu = 0; //флаг работы с меню
	int temp = 0; //флаг работы с вводом
	int Deep = 0; //текущая глубина
	int maxDeep = 5; //максимальная глубина
	List* root = NULL; //начало очереди
	Sequence* taken = NULL; //буфер
	//цикл реализующий работу меню в диалоговом режиме
	while (!menu) {
		printf("1. Начать работу с очередью\n");//
		printf("2. Сделать очередь пустой\n");//
		printf("3. Пуста ли очередь?\n");//
		printf("4. Показать последовательность в начале очереди\n");//
		printf("5. Удалить начало очереди\n");//
		printf("6. Взять последовательность из начала очереди\n");//?
		printf("7. Изменить значение последовательности в начале очереди\n");//
		printf("8. Добавить элемент в конец очереди\n");//
		printf("9. Распечатать очередь\n");//
		printf("10. Завершить работу\n");//
		//ввод команды пользователем
		scanf_s("%d", &temp);
		system("cls"); // очищение экрана
		int y = 0;
		y = getchar();
		while (y != '\n') {
			y = getchar();
		}
		//проверка активации программы
		if (!isActive && (temp != 10) && (temp != 1)) {
			printf("\nДля доступа к этой функции необходимо начать работу\n\n");
			temp = 0;
		}
		else
		{
			//проверка верности формата ввода
			if (temp == 0) {
				printf("\nНеверный формат команды\n\n");
			}
		}
		//ветвление, реализующее вызов заданной пользователем команды
		switch (temp)
		{
		case 1:
			// Активация меню
			isActive = StartWork(isActive);
			break;
		case 2:
			// Удаляет список полностью
			root = MakeListEmpty(root);
			Deep = 0;
			break;
		case 3:
			//Проверяет, пуст ли список
			IsListEmpty(root);
			break;
		case 4:
			// Печатает начало очереди
			ShowListonStart(root);
			break;
		case 5:
			// Удаляет начало очереди
			root = DeleteStartList(root);
			Deep--;
			break;
		case 6:
			// Помещает начало очереди в буфер
			root = TakeElementList(root, &taken);
			Deep--;
			break;
		case 7:
			// Изменяет начало очереди
			root = ChangeSequenceonList(root);
			//Проверка, не пуста ли очередь
			if (root) {
				// Если очередь пуста
				if (!root->Root) {
					// Удаляет начало очереди
					root = DeleteStartList(root);
				}
			}
			break;
		case 8:
			if (Deep != maxDeep) {
				//Проверка, какой по счёту элемент очереди добавляет пользователь
				if (root == NULL) {
					//Если первый - вызывает соответствующую функцию
					root = AddFirstList();
				}
				// Иначе, добавляет в конец очереди очередной элемент
				else
				{
					// Добавляет элемент в конец очереди
					AddList(root);
				}
				Deep++;
			}
			else {
				printf("Нельзя добавить элемент.Так как очередь заполнена.\n");
			}
			break;
		case 9:
			// Печатает очередь полностью
			PrintList(root);
			break;
		case 10:
			// Заканчивает работу с меню
			menu = EndWorkSentence(menu);
			break;
		}
		//Печатает очередь и рабочий указатель
		if (isActive) {
			printf("\n");
			PrintJList(root);
			printf("\n");
		}
		temp = 0;
	}
}

void showElementInPtr(Sequence* element) {
	if (!element) {
		cout << "Отсутствуют какие-либо записи" << endl;
	}
	else {
		//Если за указателем есть предложение - вызывает функцию печати
		if (element->Root != NULL) {
			PrintSentence(element->Root);
		}
		//Иначе, выводит сообщение
		else {
			printf("\nУказатель находится на последнем элементе, нельзя показать\n\n");
		}
	}
}

Sentence* ReadElementPosledovateln(Sequence* j) { // 6 пункт последовательности
		//Если за указателем есть элемент - перемещает его вперёд
	if (j->Root != NULL) {
		return j->Root;
	}
}

void IsJonStartSequance(Sequence* j, Sequence* head) {
	// Если значение указателя равно NULL
	if (!j) {
		printf("\nОтсутствубт какие-либо записи\n\n");
	}
	// Если значение указателя отлично от NULL
	else
	{
		//Если до указателя есть элемент, печатает соответствующее сообщение
		if (j == head) {
			printf("Отсутствует элементы в  прочитанной части\n");
		}
		else {
			printf("Прочитанная часть не пуста!\n");
			if (j->next == NULL) {
				printf("Нет не прочитанных элементов\n");
			}
			else {
				printf("Есть не прочитанные элементы\n");
			}
		}
	}
}

//Главная функция, из которой начинается работы
void main()
{
	//Изменение языка консоли
	setlocale(LC_ALL, "Russian");
	//Старт работы с очередью
	WorkWithList();
}
